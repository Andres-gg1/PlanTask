{"name": "test_register_invalid_passwords[NoSpecial1]", "status": "broken", "statusDetails": {"message": "  File \"C:\\Users\\itzelh5\\PlanTask-2\\plantask\\plantask\\views\\auth.py\", line 106\n    failed_email_attempts[failed_emails for failed_emails in failed_email_attempts if email not in failed_email_attempts ]\n                                        ^^^\nSyntaxError: invalid syntax", "trace": "@pytest.fixture\n    def testapp():\n        # Setup the app for testing with specific settings\n        settings = {\n            'sqlalchemy.url': TESTING_DATABASE_URL,\n            'testing': True,\n        }\n>       app = main({}, **settings)\n\ntests\\test_auth_endpoin.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nplantask\\__init__.py:63: in main\n    config.scan()\nenv\\Lib\\site-packages\\pyramid\\config\\__init__.py:880: in scan\n    scanner.scan(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <venusian.Scanner object at 0x000001AE2C5563F0>, package = <module 'plantask' from 'C:\\\\Users\\\\itzelh5\\\\PlanTask-2\\\\plantask\\\\plantask\\\\__init__.py'>, categories = ('pyramid',), onerror = None, ignore = []\n\n    def scan(self, package, categories=None, onerror=None, ignore=None):\n        \"\"\"Scan a Python package and any of its subpackages.  All\n        top-level objects will be considered; those marked with\n        venusian callback attributes related to ``category`` will be\n        processed.\n    \n        The ``package`` argument should be a reference to a Python\n        package or module object.\n    \n        The ``categories`` argument should be sequence of Venusian\n        callback categories (each category usually a string) or the\n        special value ``None`` which means all Venusian callback\n        categories.  The default is ``None``.\n    \n        The ``onerror`` argument should either be ``None`` or a callback\n        function which behaves the same way as the ``onerror`` callback\n        function described in\n        http://docs.python.org/library/pkgutil.html#pkgutil.walk_packages .\n        By default, during a scan, Venusian will propagate all errors that\n        happen during its code importing process, including\n        :exc:`ImportError`.  If you use a custom ``onerror`` callback, you\n        can change this behavior.\n    \n        Here's an example ``onerror`` callback that ignores\n        :exc:`ImportError`::\n    \n            import sys\n            def onerror(name):\n                if not issubclass(sys.exc_info()[0], ImportError):\n                    raise # reraise the last exception\n    \n        The ``name`` passed to ``onerror`` is the module or package dotted\n        name that could not be imported due to an exception.\n    \n        .. versionadded:: 1.0\n           the ``onerror`` callback\n    \n        The ``ignore`` argument allows you to ignore certain modules,\n        packages, or global objects during a scan.  It should be a sequence\n        containing strings and/or callables that will be used to match\n        against the full dotted name of each object encountered during a\n        scan.  The sequence can contain any of these three types of objects:\n    \n        - A string representing a full dotted name.  To name an object by\n          dotted name, use a string representing the full dotted name.  For\n          example, if you want to ignore the ``my.package`` package *and any\n          of its subobjects or subpackages* during the scan, pass\n          ``ignore=['my.package']``.\n    \n        - A string representing a relative dotted name.  To name an object\n          relative to the ``package`` passed to this method, use a string\n          beginning with a dot.  For example, if the ``package`` you've\n          passed is imported as ``my.package``, and you pass\n          ``ignore=['.mymodule']``, the ``my.package.mymodule`` mymodule *and\n          any of its subobjects or subpackages* will be omitted during scan\n          processing.\n    \n        - A callable that accepts a full dotted name string of an object as\n          its single positional argument and returns ``True`` or ``False``.\n          For example, if you want to skip all packages, modules, and global\n          objects with a full dotted path that ends with the word \"tests\", you\n          can use ``ignore=[re.compile('tests$').search]``.  If the callable\n          returns ``True`` (or anything else truthy), the object is ignored,\n          if it returns ``False`` (or anything else falsy) the object is not\n          ignored.  *Note that unlike string matches, ignores that use a\n          callable don't cause submodules and subobjects of a module or\n          package represented by a dotted name to also be ignored, they match\n          individual objects found during a scan, including packages,\n          modules, and global objects*.\n    \n        You can mix and match the three types of strings in the list.  For\n        example, if the package being scanned is ``my``,\n        ``ignore=['my.package', '.someothermodule',\n        re.compile('tests$').search]`` would cause ``my.package`` (and all\n        its submodules and subobjects) to be ignored, ``my.someothermodule``\n        to be ignored, and any modules, packages, or global objects found\n        during the scan that have a full dotted name that ends with the word\n        ``tests`` to be ignored.\n    \n        Note that packages and modules matched by any ignore in the list will\n        not be imported, and their top-level code will not be run as a result.\n    \n        A string or callable alone can also be passed as ``ignore`` without a\n        surrounding list.\n    \n        .. versionadded:: 1.0a3\n           the ``ignore`` argument\n        \"\"\"\n    \n        pkg_name = package.__name__\n    \n        if ignore is not None and (\n            isinstance(ignore, str) or not hasattr(ignore, \"__iter__\")\n        ):\n            ignore = [ignore]\n        elif ignore is None:\n            ignore = []\n    \n        # non-leading-dotted name absolute object name\n        str_ignores = [ign for ign in ignore if isinstance(ign, str)]\n        # leading dotted name relative to scanned package\n        rel_ignores = [ign for ign in str_ignores if ign.startswith(\".\")]\n        # non-leading dotted names\n        abs_ignores = [ign for ign in str_ignores if not ign.startswith(\".\")]\n        # functions, e.g. re.compile('pattern').search\n        callable_ignores = [ign for ign in ignore if callable(ign)]\n    \n        def _ignore(fullname):\n            for ign in rel_ignores:\n                if fullname.startswith(pkg_name + ign):\n                    return True\n            for ign in abs_ignores:\n                # non-leading-dotted name absolute object name\n                if fullname.startswith(ign):\n                    return True\n            for ign in callable_ignores:\n                if ign(fullname):\n                    return True\n            return False\n    \n        def invoke(mod_name, name, ob):\n            fullname = mod_name + \".\" + name\n    \n            if _ignore(fullname):\n                return\n    \n            category_keys = categories\n            try:\n                # Some metaclasses do insane things when asked for an\n                # ``ATTACH_ATTR``, like not raising an AttributeError but\n                # some other arbitary exception.  Some even shittier\n                # introspected code lets us access ``ATTACH_ATTR`` far but\n                # barfs on a second attribute access for ``attached_to``\n                # (still not raising an AttributeError, but some other\n                # arbitrary exception).  Finally, the shittiest code of all\n                # allows the attribute access of the ``ATTACH_ATTR`` *and*\n                # ``attached_to``, (say, both ``ob.__getattr__`` and\n                # ``attached_categories.__getattr__`` returning a proxy for\n                # any attribute access), which either a) isn't callable or b)\n                # is callable, but, when called, shits its pants in an\n                # potentially arbitrary way (although for b, only TypeError\n                # has been seen in the wild, from PyMongo).  Thus the\n                # catchall except: return here, which in any other case would\n                # be high treason.\n                attached_categories = getattr(ob, ATTACH_ATTR)\n                if not attached_categories.attached_to(mod_name, name, ob):\n                    return\n            except:\n                return\n            if category_keys is None:\n                category_keys = list(attached_categories.keys())\n                try:\n                    # When metaclasses return proxies for any attribute access\n                    # the list may contain keys of different types which might\n                    # not be sortable.  In that case we can just return,\n                    # because we're not dealing with a proper venusian\n                    # callback.\n                    category_keys.sort()\n                except TypeError:  # pragma: no cover\n                    return\n            for category in category_keys:\n                callbacks = attached_categories.get(category, [])\n                try:\n                    # Metaclasses might trick us by reaching this far and then\n                    # fail with too little values to unpack.\n                    for callback, cb_mod_name, liftid, scope in callbacks:\n                        if cb_mod_name != mod_name:\n                            # avoid processing objects that were imported into\n                            # this module but were not actually defined there\n                            continue\n                        callback(self, name, ob)\n                except ValueError:  # pragma: nocover\n                    continue\n    \n        for name, ob in getmembers(package):\n            # whether it's a module or a package, we need to scan its\n            # members; walk_packages only iterates over submodules and\n            # subpackages\n            invoke(pkg_name, name, ob)\n    \n        if hasattr(package, \"__path__\"):  # package, not module\n            results = walk_packages(\n                package.__path__,\n                package.__name__ + \".\",\n                onerror=onerror,\n                ignore=_ignore,\n            )\n    \n            for importer, modname, ispkg in results:\n                loader = compat_find_loader(importer, modname)\n                if loader is not None:  # happens on pypy with orphaned pyc\n                    try:\n                        get_filename = getattr(loader, \"get_filename\", None)\n                        if get_filename is None:  # pragma: nocover\n                            get_filename = loader._get_filename\n                        try:\n                            fn = get_filename(modname)\n                        except TypeError:  # pragma: nocover\n                            fn = get_filename()\n    \n                        # NB: use __import__(modname) rather than\n                        # loader.load_module(modname) to prevent\n                        # inappropriate double-execution of module code\n                        try:\n>                           __import__(modname)\nE                             File \"C:\\Users\\itzelh5\\PlanTask-2\\plantask\\plantask\\views\\auth.py\", line 106\nE                               failed_email_attempts[failed_emails for failed_emails in failed_email_attempts if email not in failed_email_attempts ]\nE                                                                   ^^^\nE                           SyntaxError: invalid syntax\n\nenv\\Lib\\site-packages\\venusian\\__init__.py:220: SyntaxError"}, "parameters": [{"name": "password", "value": "'NoSpecial1'"}], "start": 1745264301229, "stop": 1745264301229, "uuid": "426ce57d-670f-41b2-8c56-e0eba7893f87", "historyId": "08ca77f448d13c98d9f1b3cd9f3d58f3", "testCaseId": "7e53ee122fdda9220177b7078bb02da2", "fullName": "tests.test_auth_endpoin#test_register_invalid_passwords", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_auth_endpoin"}, {"name": "host", "value": "PC-5CG1400DWZ"}, {"name": "thread", "value": "22464-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_auth_endpoin"}]}